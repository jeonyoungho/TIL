# 자바 면접 대비

#### 자바의 장단점에 대해 말할 수 있나요?
- 장점
    - JVM위에서 동작하기 떄문에 플랫폼에 독립적
    - GC가 메모리를 관리해주기 때문에 편리함
- 단점
    - JVM위에서 동작하기 때문에 실행 속도가 상대적으로 느림
    - 다중 상속이나 타입에 엄격하는 등 제약이 많음

#### 추상 클래스와 인터페이스의 차이는 무엇인가요?
- 추상 클래스
    - 단일 상속만 가능
    - 모든 접근 제어자를 사용 가능
    - 변수와 상수를 선언할 수 있음
    - 추상 메소드와 일반 메소드를 선언 가능
- 인터페이스
    - 다중 구현이 가능
    - public 접근 제어자만 사용 가능
    - 상수만 선언 가능
    - 추상메소드만 선언 가능

#### List, Set, Map에 대해 설명해주세요.
- List
    - 데이터를 순차적으로 저장
    - 데이터 중복을 허용
    - 데이터로 null을 허용
- Set
    - 데이터를 순서없이 Key로만 저장
    - Key의 중복을 허용하지 않음
    - Key로 null을 허용하지 않음
- Map
    - 순서 없이 Key, Value형태로 데이터를 저장
    - Value는 중복을 허용하지만 Key는 중복을 허용하지 않음
    - Key는 중복을 허용하지 않음

#### Java의 Vector와 ArrayList 차이는 무엇인가요?
- Vector
    - <b>동기화를 지원</b>하기 때문에 Thread-Safe
    - 삽입, 삭제 등 연산 시 Synchronized키워드로 인해 <b>속도가 느림</b>
    - 크기가 증가하는 경우, 2배 증가 (10 -> 20)
- ArrayList
    - <b>동기화를 지원하지 않기</b> 때문에 멀티스레드 방식에서 안전하지 않음
    - <b>속도가 빠름</b>
    - 크기가 증가하는 경우, 1.5배 증가 (10->15)


#### Java에서 ArrayList와 LinkedList의 차이에 대해 설명해주세요.
- ArrayList는 데이터를 배열에서 관리하며 데이터의 추가 및 삭제를 위해 아래와 같이 임시 배열을 생성해 데이터를 복사하는 방법을 이용합니다.<br>
<img width="267" alt="9" src="https://user-images.githubusercontent.com/44339530/114520805-c5013300-9c7c-11eb-9382-7ac473944829.png"><br>

- LinkedList는 데이터를 저장하는 각 노드가 이전 노드와 다음 노드의 상태만 알고 있는 구조입니다.

- 따라서 데이터의 검색이 빈번할시에는 ArrayList를 사용하는 것이 시간복잡도 측면에서 O(1)으로 유리하며 데이터의 삽입 삭제가 빈번할시에는 LinkedList를 사용하는 것이 O(1)의 시간복잡도로 유리합니다.



#### StringBuffer와 StringBuilder의 차이는 무엇인가요?
- StringBuilder
    - 동기화를 지원하지 않음
    - 속도는 빠르지만 멀티 스레드 방식에서 안전하지 못함
- StringBuffer
    -  동기화를 지원함
    - 속도가 느리지만 멀티 스레드 방식에서 안전함

#### 자바 애플리케이션의 동작 과정에 대해 설명해주세요.
![5](https://user-images.githubusercontent.com/44339530/114513118-d0506080-9c74-11eb-981b-1b0c9e7eed53.png)<br>
- 1) 먼저 java 소스 파일(.java)을 javac(자바 컴파일러)가 컴파일 후 Java 바이트 코드로된 class 파일을 생성함
- 2) 클래스 로더가 컴파일된 class 파일을 런타임 데이터 영역(Runtime Data Areas)에 로드시킴
- 3) 실행 엔진(Execution Engine)이 자바 바이트 코드를 실행함

#### 전체적인 JVM의 구조에 대해 설명할 수 있나요?
- 1) Class loader: 클래스 파일들을 Runtime Data Area에 올리는 역할
- 2) GC: 메모리 상에 참조되지 않는 객체들을 제거하는 역할
- 3) Execution engine: 실제 코드들을 실행시키는 역할
- 4) Runtime Data Area: 애플리케이션 실행과 관련된 모든 데이터를 저장하는 역할

#### JVM의 메모리 구조(Runtime Data Area)에 대해 설명할 수 있나요?
![6](https://user-images.githubusercontent.com/44339530/114513571-4b197b80-9c75-11eb-8d72-d08648106eea.png)<br>
- 1) Method Area(메소드 영역): 클래스와 관련된 정보를 저장하며 static 변수 및 인터페이스 등도 저장된다.
- 2) Heap Area(힙 영역): new를 통해 생성된 객체와 배열의 인스턴스가 저장된다. GC의 대상이 된다.
- 3) Stack Area(스택 영역): 메소드가 실행되면 스택영역에 메소드에 대한 영역이 1개 생김. 이 영역에 지역변수, 매개변수, 리턴값 등이 저장된다.
- 4) PC register(PC 레지스터): 현재 스레드가 실행되는 부분의 주소와 명령이 저장된다.
- 5) Native Method Stack(네이티브 메소드 스택): 자바 외의 언어로 작성된 코드들이 저장된다. JNI를 통해 사용된다.


#### synchornized란 무엇인가요?
- Java에서 지원하는 synchronized 키워드는 여러 스레드가 하나의 자원을 이용하고자 할 때, 한 스레드가 해당 자원을 사용중인 경우, 다른 스레드가 데이터에 접근할 수 없도록 막는 키워드입니다. synchronized 키워드를 이용하면 병렬 상황에서 자원의 접근을 안전하게 하지만, 자원을 이용하지 않는 스레드는 락에 의한 병목현상이 발생하게 됩니다.
    - 메소드 synchronized: 한 시점에 하나의 스레드만이 해당 메소드를 실행 할 수 있음
    - 변수 synchronized: 한 시점에 하나의 스레드만이 해당 변수를 참조할 수 있음

#### 클래스, 객체, 인스턴스의 개념 및 각각의 차이는 무엇인가요?
- 객체는 소프트웨어 세계에 구현할 대상이며 클래스는 객체를 만들어내기 위한 설계도입니다. 객체가 실제로 생성되어 메모리에 할당이 된 구체적인 실체가 인스턴스가 됩니다.
- 즉 클래스는 '설계도', 객체는 '설계도로 구현한 대상', 인스턴스는 '실제로 메모리에 할당된 객체'를 의미합니다.

#### Override와 Overload의 차이는 무엇인가요?
- 오버라이딩은 상위클래스가 가지고 있는 메서드를 하위 클래스에서 재정의 후 사용하는 것이며 오버로드는 같은 이름의 메서드 여러개를 가지면서 매개변수의 유형과 개수를 다르도록 하는 기술입니다. 

- 둘 다 자바의 다형성을 지원하는 방법이며 오버라이딩은 재정의된 메서드의 이름, 매개변수 타입 및 개수, 리턴타입이 전부 동일하지만 오버로딩은 메서드 이름은 같지만 매개변수 타입 및 개수가 달라야만합니다.

|구분|오버로딩|오버라이딩|
|------|------|------|
|메서드 이름|동일|동일|
|매개변수, 타입|다름|동일|
|리턴타입|상관없음|동일|


#### 가비지 컬렉터에 대해 이야기해주세요.
- '더 이상 참조되지 않는 메모리'인 가비지를 청소해주는 JVM 실행 엔진의 한 요소입니다. new와 같은 연산에 의해 Heap영역에 생성된 인스턴스 중에서 더 이상 참조되지 않는 인스턴스를 메모리에서 제거해줍니다. 

#### 가비지 컬렉터의 과정에 대해 이야기해주세요.
- 가비지 컬렉터는 메모리를 정리하는 과정이기에 메모리의 사용을 중단한 채로 진행되어야 합니다. 

- JVM은 GC를 실행하기 위해 애플리케이션의 실행을 멈추는 stop-the-world를 먼저 실행하게 됩니다. 그러면 GC를 실행하는 스레드를 제외한 모든 스레드가 작업을 멈춥니다. 이후 GC가 끝나면 다시 작업을 재개합니다.

- GC의 작업은 Young영역에 대한 Minor GC와 Old 영역에 대한 Major GC로 구분됩니다.
    - Young 영역: 새롭게 생성한 객체들이 위치하는 영역
    - Old영역: Young 영역에서 계속 사용되어 살아남은 객체가 복사되는 영역, Young영역보다 더 크게 할당되며 더 적은 GC가 발생한다.

- Young 영역은 1개의 Eden 영역과 2개의 Survivor 영역으로 구서오디는데, Young 영역에 대한 GC는 다음과 같이 동작합니다.
    - 1) 새로운 객체가 Eden 영역에 생성됨
    - 2) Eden 영역에 GC가 동작하고, 그 중에서 살아남은 객체가 Survivor0으로 이동함
    - 3) 2번의 동작이 반복되어 Survivor0이 꽉 차게 됨
    - 4) Survivor0영역에 GC가 동작하고, 살아남은 객체들은 Survivor1으로 이동하고 Survivor0을 비우게 됨(2개의 Survivor 영역 중 1개는 반드시 비어 있어야 됨)
    - 5) 위의 동작들이 반복되어 특정 횟수만큼 살아남은 객체는 Old영역으로 이동하게 됨<br>
    - ![1](https://user-images.githubusercontent.com/44339530/114509928-0a1f6800-9c71-11eb-82d0-f230fec2b120.png)<br>

- Old영역이 가득차서 Survivor 영역에서 Old영역으로 이동이 불가능할 때 Old영역에 Major GC가 일어나게 됨

#### 가비지 컬렉터의 종류에 대해 설명할 수 있나요?
- 1) Serial GC: mark-sweep-compact 알고리즘을 사용한다. <b>Old영역에서 살아있는 객체를 식별하고, 살아있는 객체만을 남긴다.(Sweep) 그리고 난 후에 객체들을 앞부분부터 채워 객체가 존재하는 부분과 존재하지 않는 부분으로 나눈다.(Compaction)</b><br>
![2](https://user-images.githubusercontent.com/44339530/114511134-78b0f580-9c72-11eb-8161-19165ea4bdb0.png)

- 2) Parallel GC: <b>Serial GC와 동일하게 mark-sweep-compact알고리즘을 사용하지만 멀티 스레드 방식을 적용</b>하여 GC를 처리한다.

- 3) Parrel Old GC: mark-sweep-compact 알고리즘의 sweep대신 summary를 사용한다. summary단계는 앞서 GC를 수행한 영역에 대해 별도로 살아있는 객체를 식별하며 Sweep보다 조금 더 복잡하다.

- 4) Concurrent Mark & Sweep GC(CMS): Initial Mark 단계에서는 살아 있는 객체를 찾는 것으로 끝낸다.(Stop-the-World 시간이 짧음) 그리고 찾은 객체에서 참조하는 개체를 Concurrent하게(여러 스레드가 동시에) 따라가는 Concurrent Mark 단계가 수행된다. 그 이후에 Stop-the-World가 실행되고 Concurrent하게 Remark가 동작한다. 이 방식은 애플리케이션의 응답속도가 매우 중요할 때 사용한다.<br>
![3](https://user-images.githubusercontent.com/44339530/114511149-7d75a980-9c72-11eb-9be3-c3ccee7faf84.png)<br>

- 5) G1(Garbage First) GC: 바둑판의 각 영역에 객체를 할당하고 GC를 실행한다. 위에서 설명한 Young영역과 Old영역에 대한 개념을 사용하지 않고, 객체를 할당한다.<br>
![4](https://user-images.githubusercontent.com/44339530/114511151-7ea6d680-9c72-11eb-9fcd-bac70c1ca90e.png)<br>


#### 출처
- https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html
- https://mangkyu.tistory.com/94